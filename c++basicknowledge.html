<!doctype html>
<html>
  <head>
    <meta charset="GB18030">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>岚博基尼by wojiaoxulan</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
 
    <script src="javascripts/respond.js"></script>
  
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
     <div id="header" align="center">
      <font size="6" >
      	岚的博客
      </font>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
      <div id="title">
      <img src="/images/snow.jpg" height="200" width="200"  style="float:left"/> <a href="index.html"><font size="4">
      &nbsp;&nbsp;博主：岚博基尼</font></a><br></br>
      <font size="2"> 
      &nbsp;&nbsp;格言：    学而时习之 锲而不舍<br></br>
      &nbsp;&nbsp;email：   437694562@qq.com<br></br>
      &nbsp;&nbsp;自我评价：教练！我想当码农！<br></br>
      </font>
      <br clear="left"></br><hr>
      </div>
       
       <div align="center">
<p></p>
<h1>string</h1>
<div align="left">

<ul>
<li><p><span style="color:#E53333;"><b>读写string:</b></span> 使用cin读取string，会忽略字符串开头和结尾的空白（空格、换行符、制表符等）。
使用getline()可以读取一整行字符串，直到遇到换行符为止，保留空白符。
<br></p>
<pre><code>  string line;
  getline(cin, line, end);   
</li>
　　cin:输入流iostream；line：输入的字符串保存在line中；end：结束符，遇到该字符停止读入</code></pre>
<li><p><span style="color:#E53333;"><b>empty和size操作:</b></span> 
<br>　　empty()函数返回字符串是否为空，如果字符串为空，返回1；反之返回0。
<br>　　size()函数返回字符串string的长度，即string对象中字符的个数。</p>
</li>
</ul>
<p>　　在这里定义了string类型的别名pos，这样使用pos和string是一样的。这种方式可以使得变量声明比较简练，
也可以防止用户知道类的实现细节。

</p>
<p></p><div align="center">
<p></p>
<h1>vector</h1>
<div align="left">

<ul>
<li><span style="color:#E53333;"><b>vector:</b></span> 表示对象的集合，所有对象的类型均相同，是一个类模板，也被称作<span style="color:#E53333;">容器</span>。
<br><pre><code>  vector&lt;int&gt; ve;             //对象类型为int的vector
  vector&lt;vector&lt;int&gt;&gt; file;   //对象类型为vector对象的vector</code></pre>
　　引用不是对象，因此不能作为vector的元素。</li>
<li><p><span style="color:#E53333;"><b>vector初始化:</b></span> </p>
<pre><code>  vector&lt;T&gt; v1(n, val);       //v1包含n个重复的元素，所有元素的值为val
  vector&lt;T&gt; v2{a, b, c...};   //v2包含初始值个数的元素，每个元素被赋予相应的初始值</code></pre>
</li>
<li><p><span style="color:#E53333;"><b>vector支持的操作:</b></span> </p>
<pre><code>  v.empty()          //判断容器是否为空。
  v.size()           //返回容器中实际数据的个数。
  v.push_back(t)     //在尾部加入一个元素t
  v.pop_back()       //删除最后一个元素
  v.capacity()       //返回容器中数据的个数
  v.clear()          //移除所有元素
  v.front()          //传回第一个数据</code></pre>
<p>　　还有一些操作，懒得写了。。。
</p><div align="center"><p></p>
<h1>迭代器</h1>
<div align="left">
</div></div></li>
<li><p><span style="color:#E53333;"><b>迭代器:</b></span> 类似于指针，迭代器并非通过取址获得。如果一个类型拥有迭代器，那么也同时拥有成员</p>
<pre><code>  v.begin()    //指向第一个元素
  v.end()      //指向尾元素的下一个位置</code></pre>
<p>　　如果v为空，那么v.begin()和v.end()相等。</p>
</li>
<li><p><span style="color:#E53333;"><b>迭代器的一些操作:</b></span> </p>
<pre><code>  *iter           //返回迭代器iter所指元素的引用
  iter-&gt;mem       //解引用iter并访问其成员mem
  ++iter          //令iter指向容器的下一个元素
  --iter          //令iter指向容器的上一个元素
  iter1 == iter2  //判断两个迭代器是否指向同一个元素
  iter1 != iter2  //同上</code></pre>
</li>
</ul>

      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
